river.names)
# NETE SECTION (precompiled as Europe entire file is very large)
nete <- load.shapefile("./data/europe_water/nete.shp",
"nete",
coordinate.string,
subset.names = NULL)
## to restart from the entire Europe shapefile:
## nete <- load.shapefile("./data/europe_water/Europe_Water_2008.shp",
##                        "Europe_Water_2008",
##                        coordinate.string,
##                        c("Nete", "Grote Nete"))
# WESTERSCHELDE
westerschelde <- load.shapefile("./data/westerschelde_water/seavox_sea_area_polygons_v13.shp",
"seavox_sea_area_polygons_v13",
coordinate.string)
# SEA
sea <- load.shapefile("./data/PJ_manual_water/PJ_ontbrekende_stukken_reduced.shp",
"PJ_ontbrekende_stukken_reduced",
coordinate.string)
# RIVER FROME (UK)
frome <- load.shapefile("./data/UK/Frome/Statutory_Main_River_Map.shp",
"Statutory_Main_River_Map",
coordinate.string)
study.area <- gUnion(rivers, nete)
study.area <- gUnion(study.area, westerschelde)
study.area <- gUnion(study.area, sea)
rm(rivers, nete, westerschelde, sea)
# LifeWatch network
locations.receivers <- load.receivers("./data/receivernetwork_20160526.csv",
coordinate.string)
nrows <- 2000
ncols <- 4000
study.area.binary <- shape.to.binarymask(study.area, nrows, ncols)
class(frome)
class(study.area)
# NETE SECTION (precompiled as Europe entire file is very large)
nete <- load.shapefile("./data/europe_water/nete.shp",
"nete",
coordinate.string,
subset.names = NULL)
class(nete)
# NETE SECTION (precompiled as Europe entire file is very large)
nete <- load.shapefile("./data/europe_water/nete.shp",
"nete",
coordinate.string,
subset.names = NULL)
library("sp")
library("rgdal")
library("rgeos")
library("raster")
library("gdistance")
library("assertthat")
# --------------------
# INTRODUCTION
# --------------------
# Define the projection for the analysis:
coordinate.string <- CRS("+init=epsg:32631")
# NETE SECTION (precompiled as Europe entire file is very large)
nete <- load.shapefile("./data/europe_water/nete.shp",
"nete",
coordinate.string,
subset.names = NULL)
# Load the functionalities from the functions file:
source("receiver_distance_fun.R")
# NETE SECTION (precompiled as Europe entire file is very large)
nete <- load.shapefile("./data/europe_water/nete.shp",
"nete",
coordinate.string,
subset.names = NULL)
class(nete)
river.names <- c("Schelde", "Durme", "Rupel", "Netekanaal",
"Albertkanaal", "Royerssluis", "Leopolddok",
"Amerikadok", "Vijfde Havendok", "Kanaaldok B3", "Delwaidedok",
"Schelde-Rijnkanaal", "Berendrechtsluis", "Hansadok",
"Kanaaldok B2", "Schelde-Rijn Kanaal",
"Zandvlietsluis", "Ringvaart", "Tijarm",
"Kanaal van Gent naar Oostende")
## for future usage:
# "Meuse", "Juliana Kanaal", "Canal Albert", "Demer", "Dijle"
rivers <- load.shapefile("./data/lowcountries_water/LowCountries_Water_2004.shp",
"LowCountries_Water_2004",
coordinate.string,
river.names)
# WESTERSCHELDE
westerschelde <- load.shapefile("./data/westerschelde_water/seavox_sea_area_polygons_v13.shp",
"seavox_sea_area_polygons_v13",
coordinate.string)
# SEA
sea <- load.shapefile("./data/PJ_manual_water/PJ_ontbrekende_stukken_reduced.shp",
"PJ_ontbrekende_stukken_reduced",
coordinate.string)
# RIVER FROME (UK)
frome <- load.shapefile("./data/UK/Frome/Statutory_Main_River_Map.shp",
"Statutory_Main_River_Map",
coordinate.string)
class(frome)
library("sp")
library("sf")
library("rgdal")
library("rgeos")
library("raster")
library("gdistance")
library("assertthat")
# --------------------
# INTRODUCTION
# --------------------
# Define the projection for the analysis:
# coordinate.string <- CRS("+init=epsg:32631")
projection_code <- 32631
# Load the functionalities from the functions file:
source("receiver_distance_fun.R")
# --------------------
river.names <- c("Schelde", "Durme", "Rupel", "Netekanaal",
"Albertkanaal", "Royerssluis", "Leopolddok",
"Amerikadok", "Vijfde Havendok", "Kanaaldok B3", "Delwaidedok",
"Schelde-Rijnkanaal", "Berendrechtsluis", "Hansadok",
"Kanaaldok B2", "Schelde-Rijn Kanaal",
"Zandvlietsluis", "Ringvaart", "Tijarm",
"Kanaal van Gent naar Oostende")
## for future usage:
# "Meuse", "Juliana Kanaal", "Canal Albert", "Demer", "Dijle"
rivers <- load.shapefile("./data/lowcountries_water/LowCountries_Water_2004.shp",
"LowCountries_Water_2004",
projection_code,
river.names)
# NETE SECTION (precompiled as Europe entire file is very large)
nete <- load.shapefile("./data/europe_water/nete.shp",
"nete",
projection_code,
subset.names = NULL)
## to restart from the entire Europe shapefile:
## nete <- load.shapefile("./data/europe_water/Europe_Water_2008.shp",
##                        "Europe_Water_2008",
##                        projection_code,
##                        c("Nete", "Grote Nete"))
# WESTERSCHELDE
westerschelde <- load.shapefile("./data/westerschelde_water/seavox_sea_area_polygons_v13.shp",
"seavox_sea_area_polygons_v13",
projection_code)
# SEA
sea <- load.shapefile("./data/PJ_manual_water/PJ_ontbrekende_stukken_reduced.shp",
"PJ_ontbrekende_stukken_reduced",
projection_code)
# RIVER FROME (UK)
frome <- load.shapefile("./data/UK/Frome/Statutory_Main_River_Map.shp",
"Statutory_Main_River_Map",
projection_code)
study.area <- gUnion(rivers, nete)
study.area <- gUnion(study.area, westerschelde)
study.area <- gUnion(study.area, sea)
# -----------------------
# SET STUDY AREA
# -----------------------
#study.area <- study.area  # When the LifeWatch network is taken into account; sea 'Combine the shape files'
study.area <- frome
# Frome network
locations.receivers <- load.receivers("./data/receivernetwork_frome_2014.csv",
projection_code)
# ------------------------
# CONVERT SHAPE TO RASTER
# ------------------------
# for alternative resolutions, change the number of rows/columns
nrows <- 2000
ncols <- 4000
study.area.binary <- shape.to.binarymask(study.area, nrows, ncols)
# --------------------------------
# ADJUST MASK TO CONTAIN RECEIVERS
# --------------------------------
study.area.binary.extended <- adapt.binarymask(study.area.binary,
locations.receivers)
library("sp")
library("sf")
library("rgdal")
library("rgeos")
library("raster")
library("gdistance")
library("assertthat")
projection_code <- 32631
# Load the functionalities from the functions file:
source("receiver_distance_fun.R")
# RIVER FROME (UK)
frome <- load.shapefile("./data/UK/Frome/Statutory_Main_River_Map.shp",
"Statutory_Main_River_Map",
projection_code)
# -----------------------
# SET STUDY AREA
# -----------------------
#study.area <- study.area  # When the LifeWatch network is taken into account; sea 'Combine the shape files'
study.area <- frome
locations.receivers <- load.receivers("./data/receivernetwork_frome_2014.csv",
projection_code)
# ------------------------
# CONVERT SHAPE TO RASTER
# ------------------------
# for alternative resolutions, change the number of rows/columns
nrows <- 2000
ncols <- 4000
study.area.binary <- shape.to.binarymask(study.area, nrows, ncols)
# --------------------------------
# ADJUST MASK TO CONTAIN RECEIVERS
# --------------------------------
study.area.binary.extended <- adapt.binarymask(study.area.binary,
locations.receivers)
# RIVER SECTION
river.names <- c("Schelde", "Durme", "Rupel", "Netekanaal",
"Albertkanaal", "Royerssluis", "Leopolddok",
"Amerikadok", "Vijfde Havendok", "Kanaaldok B3", "Delwaidedok",
"Schelde-Rijnkanaal", "Berendrechtsluis", "Hansadok",
"Kanaaldok B2", "Schelde-Rijn Kanaal",
"Zandvlietsluis", "Ringvaart", "Tijarm",
"Kanaal van Gent naar Oostende")
rivers <- load.shapefile("./data/lowcountries_water/LowCountries_Water_2004.shp",
"LowCountries_Water_2004",
projection_code,
river.names)
# NETE SECTION (precompiled as Europe entire file is very large)
nete <- load.shapefile("./data/europe_water/nete.shp",
"nete",
projection_code,
subset.names = NULL)
# WESTERSCHELDE
westerschelde <- load.shapefile("./data/westerschelde_water/seavox_sea_area_polygons_v13.shp",
"seavox_sea_area_polygons_v13",
projection_code)
# -----------------------
# COMBINE THE SHAPE FILES
# -----------------------
study.area <- gUnion(rivers, nete)
library("sp")
library("sf")
library("rgdal")
library("rgeos")
library("raster")
library("gdistance")
library("assertthat")
# --------------------
# INTRODUCTION
# --------------------
# Define the projection for the analysis:
# coordinate.string <- CRS("+init=epsg:32631")
projection_code <- 32631
# Load the functionalities from the functions file:
source("receiver_distance_fun.R")
river.names <- c("Schelde", "Durme", "Rupel", "Netekanaal",
"Albertkanaal", "Royerssluis", "Leopolddok",
"Amerikadok", "Vijfde Havendok", "Kanaaldok B3", "Delwaidedok",
"Schelde-Rijnkanaal", "Berendrechtsluis", "Hansadok",
"Kanaaldok B2", "Schelde-Rijn Kanaal",
"Zandvlietsluis", "Ringvaart", "Tijarm",
"Kanaal van Gent naar Oostende")
## for future usage:
# "Meuse", "Juliana Kanaal", "Canal Albert", "Demer", "Dijle"
rivers <- load.shapefile("./data/lowcountries_water/LowCountries_Water_2004.shp",
"LowCountries_Water_2004",
projection_code,
river.names)
# NETE SECTION (precompiled as Europe entire file is very large)
nete <- load.shapefile("./data/europe_water/nete.shp",
"nete",
projection_code,
subset.names = NULL)
## to restart from the entire Europe shapefile:
## nete <- load.shapefile("./data/europe_water/Europe_Water_2008.shp",
##                        "Europe_Water_2008",
##                        projection_code,
##                        c("Nete", "Grote Nete"))
# WESTERSCHELDE
westerschelde <- load.shapefile("./data/westerschelde_water/seavox_sea_area_polygons_v13.shp",
"seavox_sea_area_polygons_v13",
projection_code)
# SEA
sea <- load.shapefile("./data/PJ_manual_water/PJ_ontbrekende_stukken_reduced.shp",
"PJ_ontbrekende_stukken_reduced",
projection_code)
# RIVER FROME (UK)
frome <- load.shapefile("./data/UK/Frome/Statutory_Main_River_Map.shp",
"Statutory_Main_River_Map",
projection_code)
# -----------------------
# SET STUDY AREA
# -----------------------
#study.area <- study.area  # When the LifeWatch network is taken into account; sea 'Combine the shape files'
study.area <- frome
# Frome network
locations.receivers <- load.receivers("./data/receivernetwork_frome_2014.csv",
projection_code)
# ------------------------
# CONVERT SHAPE TO RASTER
# ------------------------
# for alternative resolutions, change the number of rows/columns
nrows <- 2000
ncols <- 4000
study.area.binary <- shape.to.binarymask(study.area, nrows, ncols)
# --------------------------------
# ADJUST MASK TO CONTAIN RECEIVERS
# --------------------------------
study.area.binary.extended <- adapt.binarymask(study.area.binary,
locations.receivers)
writeRaster(study.area.binary.extended, "./results/study_area_binary", "GTiff",
overwrite = TRUE)
# --------------------------------
# CONTROL MASK
# --------------------------------
# Control the mask characteristics and receiver location inside mask:
# (if an error occurs, this need to be checked before deriving distances again)
control.mask(study.area.binary.extended, locations.receivers)
# -------------------------------
# Derive distances with gdistance
# -------------------------------
cst.dst.frame <- get.distance.matrix(study.area.binary.extended,
locations.receivers)
write.csv(cst.dst.frame, "./results/frome_distances.csv")
# -----------------------
# COMBINE THE SHAPE FILES
# -----------------------
study.area <- gUnion(rivers, nete)
# -----------------------
# SET STUDY AREA
# -----------------------
#study.area <- study.area  # When the LifeWatch network is taken into account; sea 'Combine the shape files'
study.area <- frome
locations.receivers <- load.receivers("./data/receivernetwork_frome_2014.csv",
projection_code)
# ------------------------
# CONVERT SHAPE TO RASTER
# ------------------------
# for alternative resolutions, change the number of rows/columns
nrows <- 4000
ncols <- 8000
study.area.binary <- shape.to.binarymask(study.area, nrows, ncols)
# --------------------------------
# ADJUST MASK TO CONTAIN RECEIVERS
# --------------------------------
study.area.binary.extended <- adapt.binarymask(study.area.binary,
locations.receivers)
# write this to disk for loading in e.g. QGIS
writeRaster(study.area.binary.extended, "./results/study_area_binary", "GTiff",
overwrite = TRUE)
# --------------------------------
# CONTROL MASK
# --------------------------------
# Control the mask characteristics and receiver location inside mask:
# (if an error occurs, this need to be checked before deriving distances again)
control.mask(study.area.binary.extended, locations.receivers)
# -------------------------------
# Derive distances with gdistance
# -------------------------------
cst.dst.frame <- get.distance.matrix(study.area.binary.extended,
locations.receivers)
write.csv(cst.dst.frame, "./results/frome_distances2.csv")
library("sp")
library("sf")
library("rgdal")
library("rgeos")
library("raster")
library("gdistance")
library("assertthat")
# --------------------
# INTRODUCTION
# --------------------
# Define the projection for the analysis:
# coordinate.string <- CRS("+init=epsg:32631")
projection_code <- 32631
# Load the functionalities from the functions file:
source("receiver_distance_fun.R")
gudena <- load.shapefile("./data/Denmark/rivers.shp",
"rivers",
projection_code)
plot(gudena)
colnames(gudena)
# RIVER GUDENA (DENMARK)
rivers_id<- c("10", "11", "12")
gudena <- load.shapefile("./data/Denmark/rivers.shp",
"rivers",
projection_code,
river_id)
gudena <- load.shapefile("./data/Denmark/rivers.shp",
"rivers",
projection_code,
rivers_id)
gudena <- filter(gudena, rivers_id == "10")
class(gudena)
class(gudena$rivers_id)
gudena <- filter(gudena, rivers_id == 10)
# RIVER GUDENA (DENMARK)
gudena <- load.shapefile("./data/Denmark/rivers.shp",
"rivers",
projection_code)
# -----------------------
# SET STUDY AREA
# -----------------------
#study.area <- study.area  # When the LifeWatch network is taken into account; sea 'Combine the shape files'
study.area <- gudena
# Gudena network
locations.receivers <- load.receivers("./data/receivernetwork_2004_gudena.csv",
projection_code)
nrows <- 2000
ncols <- 4000
study.area.binary <- shape.to.binarymask(study.area, nrows, ncols)
# RIVER GUDENA (DENMARK)
gudena <- load.shapefile("./data/Denmark/rivers.shp",
"rivers",
projection_code)
class(gudena)
gudena = gudena[gudena$rivers_id == 10,]
plot(gudena)
gudena <- gudena[gudena$rivers_id == c(10,11,12),]
gudena <- gudena[gudena$rivers_id == 11,]
plot(gudena)
gudena <- gudena[gudena$rivers_id == 10,]
plot(gudena)
# RIVER GUDENA (DENMARK)
gudena <- load.shapefile("./data/Denmark/rivers.shp",
"rivers",
projection_code)
gudena <- gudena[gudena$rivers_id == 10,]
plot(gudena)
dev.off()
plot(gudena)
gudena <- load.shapefile("./data/Denmark/rivers.shp",
"rivers",
projection_code)
gudena <- gudena[gudena$rivers_id == 11,]
plot(gudena)
gudena <- load.shapefile("./data/Denmark/rivers.shp",
"rivers",
projection_code)
gudena <- gudena[gudena$rivers_id == 12,]
plot(gudena)
gudena <- load.shapefile("./data/Denmark/rivers.shp",
"rivers",
projection_code)
gudena <- gudena[gudena$rivers_id == 10,]
plot(gudena)
gudena <- load.shapefile("./data/Denmark/rivers.shp",
"rivers",
projection_code)
gudena <- gudena[gudena$rivers_id == 11,]
plot(gudena)
gudena <- load.shapefile("./data/Denmark/rivers.shp",
"rivers",
projection_code)
gudena <- gudena[gudena$rivers_id == 12,]
plot(gudena)
# RIVER GUDENA (DENMARK)
gudena <- load.shapefile("./data/Denmark/rivers.shp",
"rivers",
projection_code)
dev.off()
gudena <- gudena[gudena$rivers_id == 12,]
plot(gudena)
# -----------------------
# SET STUDY AREA
# -----------------------
#study.area <- study.area  # When the LifeWatch network is taken into account; sea 'Combine the shape files'
study.area <- gudena
# Gudena network
locations.receivers <- load.receivers("./data/receivernetwork_2004_gudena.csv",
projection_code)
nrows <- 2000
ncols <- 4000
study.area.binary <- shape.to.binarymask(study.area, nrows, ncols)
# --------------------------------
# ADJUST MASK TO CONTAIN RECEIVERS
# --------------------------------
study.area.binary.extended <- adapt.binarymask(study.area.binary,
locations.receivers)
# write this to disk for loading in e.g. QGIS
writeRaster(study.area.binary.extended, "./results/study_area_binary", "GTiff",
overwrite = TRUE)
# --------------------------------
# CONTROL MASK
# --------------------------------
# Control the mask characteristics and receiver location inside mask:
# (if an error occurs, this need to be checked before deriving distances again)
control.mask(study.area.binary.extended, locations.receivers)
# -------------------------------
# Derive distances with gdistance
# -------------------------------
cst.dst.frame <- get.distance.matrix(study.area.binary.extended,
locations.receivers)
write.csv(cst.dst.frame, "./results/distances_2004_gudena.csv")
# RIVER MONDEGO (PORTUGAL)
mondego <- load.shapefile("./data/Portugal/Mondego.shp",
"rivers",
projection_code)
dev.off()
# RIVER MONDEGO (PORTUGAL)
mondego <- load.shapefile("./data/Portugal/Mondego.shp",
"Mondego",
projection_code)
plot(mondego)
# Mondego network
locations.receivers <- load.receivers("./data/receivernetwork_PTN-Silver-eel-Mondego.csv",
projection_code)
nrows <- 2000
ncols <- 4000
study.area.binary <- shape.to.binarymask(study.area, nrows, ncols)
# write this to disk for loading in e.g. QGIS
writeRaster(study.area.binary.extended, "./results/study_area_binary", "GTiff",
overwrite = TRUE)
# --------------------------------
# CONTROL MASK
# --------------------------------
# Control the mask characteristics and receiver location inside mask:
# (if an error occurs, this need to be checked before deriving distances again)
control.mask(study.area.binary.extended, locations.receivers)
# -------------------------------
# Derive distances with gdistance
# -------------------------------
cst.dst.frame <- get.distance.matrix(study.area.binary.extended,
locations.receivers)
