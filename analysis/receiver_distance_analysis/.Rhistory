detections2movementmatrix <- function(detectionsDF, transmitter.id) {
edges <- detections2movementedges(detectionsDF, transmitter.id)
names <- levels(as.factor(c(edges$receiver1, edges$receiver2)))
m <- sparseMatrix(i=as.numeric(as.factor(edges$receiver1)),
j=as.numeric(as.factor(edges$receiver2)),
x=edges$freq)
movementDF <- as.data.frame(as.matrix(m))
row.names(movementDF) <- levels(as.factor(edges$receiver1))
colnames(movementDF) <- levels(as.factor(edges$receiver2))
return(movementDF)
}
# ==================================
# Generate a graph representing the movement of the fish carrying the given
# transmitter. Vertices (nodes) in the graph represent receivers while edges (arrows)
# represent movement between receivers.
# Parameters:
#    - `detectionsDF`: a dataframe with raw detections. Expected columns
#            are `stationname`, `timestamp` and `transmitter`. Other columns are ignored.
#    - `receiversDF`: a dataframe containing receiver metadata. Expected columns
#            are `station_name`, `longitude` and `latitude`. Other columns are ignored.
#    - `transmitter.id`: id of the transmitter for which a movement graph should be
#            created.
detections2graph <- function(detectionsDF, receiversDF, transmitter.id) {
edges <- detections2movementedges(detectionsDF, transmitter.id)
# select all station names that where visited
all.vertices <- c(as.character(edges$receiver1),
as.character(edges$receiver2))
# create a list of unique receivers
receivers <- unique(receiversDF[, c("station_name", "longitude", "latitude")])
# add a flag when a new transmitter starts
# create a dataframe containing all station names and their counts
unique.vertices <- count(all.vertices)
colnames(unique.vertices) <- c("station_name", "count")
# join the vertices (station names) with the receivers dataframe
vertices <- merge(unique.vertices, receivers)
# create a graph with the edges and vertices
g <- graph.data.frame(edges, vertices=vertices)
return(g)
}
#=========================================
#=========================================
# ==================================
# Generate a graph representing the movement of the fish carrying the given
# transmitter. Vertices (nodes) in the graph represent receivers while edges (arrows)
# represent movement between receivers.
# Parameters:
#    - `intervalsDF`: a dataframe with intervals. Expected columns
#            are `Station.Name`, `Arrival_time`, `Departure_time`, `Transmitter`, `X`, `Y`,
#            and `residencetime`. Other columns are ignored.
#    - `transmitter.id`: id of the transmitter for which a movement graph should be
#            created.
intervals2graph <- function(intervalsDF, transmitter.id) {
# sort the intervals DF by transmitter and arrival time
d <- intervalsDF[order(intervalsDF$Transmitter, intervalsDF$Arrival_time), ]
station.attr <- ddply(d[, c("Transmitter", "X", "Y", "Station.Name",
"residencetime", "Departure_time")],
.(Transmitter, Station.Name, X, Y), # aggregate by transmitter and station
summarize, total_time=sum(residencetime), # add total residencetime
avg_time=mean(residencetime), # add mean residencetime
last_departure=max(ymd_hms(Departure_time))
) # add last departure time
# add a flag when a new transmitter starts
d$new.transm <- c(1, diff(as.factor(d$Transmitter)))
# add a flag when the station name of the interval differs from the previous interval
d$stationdiff <- c(1, diff(as.factor(d$Station.Name)))
# create a matrix with column1 containing the previous station (reveiver1) and column2
# containing the next station (receiver2)
all.edges <- cbind(
c(0,
d[d$stationdiff != 0 & d$Transmitter==transmitter.id, "Station.Name"]
),
c(d[d$stationdiff != 0 & d$Transmitter==transmitter.id, "Station.Name"],
0)
)
edges.df <- data.frame(all.edges[2:(length(all.edges[,1]) - 1),])
colnames(edges.df) <- c("receiver1", "receiver2")
# create a dataframe containing the edges and their counts
edges <- count(edges.df)
# select all station names that where visited
all.vertices <- c(as.character(edges$receiver1),
as.character(edges$receiver2))
# create a dataframe containing all station names and their counts
unique.vertices <- count(all.vertices)
colnames(unique.vertices) <- c("Station.Name", "count")
# join the vertices (station names) with the station.attr. The one holding the additional
# attributes such as total_time and last_departure
vertices <- merge(unique.vertices, station.attr[station.attr$Transmitter==transmitter.id, ])
# create a graph with the edges and vertices
g <- graph.data.frame(edges, vertices=vertices)
return(g)
}
# ==================================
plot.migration.detections <- function(graph) {
plot(graph,
layout=cbind(V(graph)$longitude, V(graph)$latitude),
edge.curved=TRUE,
edge.width=E(graph)$freq*2,
vertex.size=6,
edge.arrow.size=0.5,
vertex.label.cex=0.7,
)
}
data2=data[which(data$Transmitter == "A69-1601-31865"), ]
g.intervals <- intervals2graph(data2, "A69-1601-31865")
plot(g.intervals)
plot.migration.detections(g.intervals)
data2=data[which(data$Transmitter == "A69-1601-29926"), ]
g.intervals <- intervals2graph(data2, "A69-1601-29926")
plot(g.intervals)
plot.migration.detections(g.intervals)
plot.migration.intervals <- function(graph) {
plot(graph,
layout=cbind(V(graph)$X, V(graph)$Y),
edge.curved=TRUE,
edge.width=E(graph)$freq*2,
vertex.size=6,
#vertex.size=V(graph)$total_time * 50 / sum(V(graph)$total_time),
edge.arrow.size=0.5,
vertex.label.cex=0.7,
vertex.color=scale.color(V(graph)$last_departure)
)
}
plot.migration.intervals(g.intervals)
plot.migration.detections(g.intervals)
scale.color(g.intervals)
load("~/Doctoraat/R/Creeks/Data_analyse PJ/Creeks_data_analysis_GlobalEnvironment.RData")
library(igraph)
library(lubridate)
library(Matrix)
library(plyr)
library(sna
)
intervals2graph <- function(intervalsDF, transmitter.id) {
# sort the intervals DF by transmitter and arrival time
d <- intervalsDF[order(intervalsDF$Transmitter, intervalsDF$Arrival_time), ]
station.attr <- ddply(d[, c("Transmitter", "X", "Y", "Station.Name",
"residencetime", "Departure_time")],
.(Transmitter, Station.Name, X, Y), # aggregate by transmitter and station
summarize, total_time=sum(residencetime), # add total residencetime
avg_time=mean(residencetime), # add mean residencetime
last_departure=max(ymd_hms(Departure_time))
) # add last departure time
# add a flag when a new transmitter starts
d$new.transm <- c(1, diff(as.factor(d$Transmitter)))
# add a flag when the station name of the interval differs from the previous interval
d$stationdiff <- c(1, diff(as.factor(d$Station.Name)))
# create a matrix with column1 containing the previous station (reveiver1) and column2
# containing the next station (receiver2)
all.edges <- cbind(
c(0,
d[d$stationdiff != 0 & d$Transmitter==transmitter.id, "Station.Name"]
),
c(d[d$stationdiff != 0 & d$Transmitter==transmitter.id, "Station.Name"],
0)
)
edges.df <- data.frame(all.edges[2:(length(all.edges[,1]) - 1),])
colnames(edges.df) <- c("receiver1", "receiver2")
# create a dataframe containing the edges and their counts
edges <- count(edges.df)
# select all station names that where visited
all.vertices <- c(as.character(edges$receiver1),
as.character(edges$receiver2))
# create a dataframe containing all station names and their counts
unique.vertices <- count(all.vertices)
colnames(unique.vertices) <- c("Station.Name", "count")
# join the vertices (station names) with the station.attr. The one holding the additional
# attributes such as total_time and last_departure
vertices <- merge(unique.vertices, station.attr[station.attr$Transmitter==transmitter.id, ])
# create a graph with the edges and vertices
g <- graph.data.frame(edges, vertices=vertices)
return(g)
}
scale.color <- function(datetimes) {
min.red <- 255
min.green <- 212
min.blue <- 00
max.red <- 16
max.green <- 130
max.blue <- 255
unix.times <- as.numeric(datetimes)
scale <- (unix.times - min(unix.times)) / (max(unix.times) - min(unix.times))
blue <- as.character(as.hexmode(round(scale * (max.blue - min.blue) + min.blue)))
red <- as.character(as.hexmode(round(scale * (max.red - min.red) + min.red)))
green <- as.character(as.hexmode(round(scale * (max.green - min.green) + min.green)))
return(paste(c("#"), red, green, blue, sep=""))
}
# ==================================
plot.migration.intervals <- function(graph) {
plot(graph,
layout=cbind(V(graph)$X, V(graph)$Y),
edge.curved=TRUE,
edge.width=E(graph)$freq*2,
vertex.size=6,
#vertex.size=V(graph)$total_time * 50 / sum(V(graph)$total_time),
edge.arrow.size=0.5,
vertex.label.cex=0.7,
vertex.color=scale.color(V(graph)$last_departure)
)
}
data2=data[which(data$Transmitter == "A69-1601-29926"), ]
g.intervals <- intervals2graph(data2, "A69-1601-29926")
plot.migration.intervals(g.intervals)
# ==================================
# Generate a graph representing the movement of the fish carrying the given
# transmitter. Vertices (nodes) in the graph represent receivers while edges (arrows)
# represent movement between receivers.
# Parameters:
#    - `intervalsDF`: a dataframe with intervals. Expected columns
#            are `Station.Name`, `Arrival_time`, `Departure_time`, `Transmitter`, `X`, `Y`,
#            and `residencetime`. Other columns are ignored.
#    - `transmitter.id`: id of the transmitter for which a movement graph should be
#            created.
intervals2graph <- function(intervalsDF, transmitter.id) {
# sort the intervals DF by transmitter and arrival time
d <- intervalsDF[order(intervalsDF$Transmitter, intervalsDF$Arrival_time), ]
station.attr <- ddply(d[, c("Transmitter", "X", "Y", "Station.Name",
"residencetime", "Departure_time")],
.(Transmitter, Station.Name, X, Y), # aggregate by transmitter and station
summarize, total_time=sum(residencetime), # add total residencetime
avg_time=mean(residencetime), # add mean residencetime
last_departure=max(ymd_hms(Departure_time))
) # add last departure time
# add a flag when a new transmitter starts
d$new.transm <- c(1, diff(as.factor(d$Transmitter)))
# add a flag when the station name of the interval differs from the previous interval
d$stationdiff <- c(1, diff(as.factor(d$Station.Name)))
# create a matrix with column1 containing the previous station (reveiver1) and column2
# containing the next station (receiver2)
all.edges <- cbind(
c(0,
d[d$stationdiff != 0 & d$Transmitter==transmitter.id, "Station.Name"]
),
c(d[d$stationdiff != 0 & d$Transmitter==transmitter.id, "Station.Name"],
0)
)
edges.df <- data.frame(all.edges[2:(length(all.edges[,1]) - 1),])
colnames(edges.df) <- c("receiver1", "receiver2")
# create a dataframe containing the edges and their counts
edges <- count(edges.df)
# select all station names that where visited
all.vertices <- c(as.character(edges$receiver1),
as.character(edges$receiver2))
# create a dataframe containing all station names and their counts
unique.vertices <- count(all.vertices)
colnames(unique.vertices) <- c("Station.Name", "count")
# join the vertices (station names) with the station.attr. The one holding the additional
# attributes such as total_time and last_departure
vertices <- merge(unique.vertices, station.attr[station.attr$Transmitter==transmitter.id, ])
# create a graph with the edges and vertices
g <- graph.data.frame(edges, vertices=vertices)
return(g)
}
scale.color <- function(datetimes) {
min.red <- 255
min.green <- 212
min.blue <- 00
max.red <- 16
max.green <- 130
max.blue <- 255
unix.times <- as.numeric(datetimes)
scale <- (unix.times - min(unix.times)) / (max(unix.times) - min(unix.times))
blue <- as.character(as.hexmode(round(scale * (max.blue - min.blue) + min.blue)))
red <- as.character(as.hexmode(round(scale * (max.red - min.red) + min.red)))
green <- as.character(as.hexmode(round(scale * (max.green - min.green) + min.green)))
return(paste(c("#"), red, green, blue, sep=""))
}
# ==================================
plot.migration.intervals <- function(graph) {
plot(graph,
layout=cbind(V(graph)$X, V(graph)$Y),
edge.curved=TRUE,
edge.width=E(graph)$freq*2,
vertex.size=6,
#vertex.size=V(graph)$total_time * 50 / sum(V(graph)$total_time),
edge.arrow.size=0.5,
vertex.label.cex=0.7,
vertex.color=scale.color(V(graph)$last_departure)
)
}
data2=data[which(data$Transmitter == "A69-1601-29926"), ]
g.intervals <- intervals2graph(data2, "A69-1601-29926")
plot(g.intervals)
plot.migration.intervals(g.intervals)
par(mar = c(0, 7, 0, 5))
plot.migration.intervals(g.intervals)
g.intervals
detections2movementmatrix <- function(intervalsDF, transmitter.id) {
edges <- detections2movementedges(intervalsDF, transmitter.id)
names <- levels(as.factor(c(edges$receiver1, edges$receiver2)))
m <- sparseMatrix(i=as.numeric(as.factor(edges$receiver1)),
j=as.numeric(as.factor(edges$receiver2)),
x=edges$freq)
movementDF <- as.data.frame(as.matrix(m))
row.names(movementDF) <- levels(as.factor(edges$receiver1))
colnames(movementDF) <- levels(as.factor(edges$receiver2))
return(movementDF)
}
matrix <- detections2movementmatrix(data2, "A69-1601-29926")
matrix <- detections2movementmatrix(intervalsDF, "A69-1601-29926")
data2=data[which(data$Transmitter == "A69-1601-29926"), ]
g.intervals <- intervals2graph(data2, "A69-1601-29926")
par(mar = c(0, 7, 0, 5))
plot.migration.intervals(g.intervals)
plot.migration.intervals <- function(graph) {
plot(graph,
layout=cbind(V(graph)$X, V(graph)$Y),
edge.curved=TRUE,
edge.width=E(graph)$freq*2,
vertex.size=6,
vertex.size=V(graph)$total_time * 50 / sum(V(graph)$total_time),
edge.arrow.size=0.5,
vertex.label.cex=0.7,
vertex.color=scale.color(V(graph)$last_departure)
)
}
data2=data[which(data$Transmitter == "A69-1601-29926"), ]
g.intervals <- intervals2graph(data2, "A69-1601-29926")
par(mar = c(0, 7, 0, 5))
plot.migration.intervals(g.intervals)
plot.migration.intervals <- function(graph) {
plot(graph,
layout=cbind(V(graph)$X, V(graph)$Y),
edge.curved=TRUE,
edge.width=E(graph)$freq*2,
#vertex.size=6,
vertex.size=V(graph)$total_time * 50 / sum(V(graph)$total_time),
edge.arrow.size=0.5,
vertex.label.cex=0.7,
vertex.color=scale.color(V(graph)$last_departure)
)
}
data2=data[which(data$Transmitter == "A69-1601-29926"), ]
g.intervals <- intervals2graph(data2, "A69-1601-29926")
par(mar = c(0, 7, 0, 5))
plot.migration.intervals(g.intervals)
detections2movementmatrix <- function(intervalsDF, transmitter.id) {
edges <- detections2movementedges(intervalsDF, transmitter.id)
names <- levels(as.factor(c(edges$Station.Name1, edges$Station.Name2)))
m <- sparseMatrix(i=as.numeric(as.factor(edges$Station.Name1)),
j=as.numeric(as.factor(edges$Station.Name2)),
x=edges$freq)
movementDF <- as.data.frame(as.matrix(m))
row.names(movementDF) <- levels(as.factor(edges$Station.Name1))
colnames(movementDF) <- levels(as.factor(edges$Station.Name2))
return(movementDF)
}
matrix <- detections2movementmatrix(intervalsDF, "A69-1601-29926")
matrix <- detections2movementmatrix(data2, "A69-1601-29926")
View(data)
edges$Station.Name1
detections2movementmatrix <- function(intervalsDF, transmitter.id) {
edges <- detections2movementedges(intervalsDF, transmitter.id)
names <- levels(as.factor(c(edges$receiver1, edges$receiver2)))
m <- sparseMatrix(i=as.numeric(as.factor(edges$receiver1)),
j=as.numeric(as.factor(edges$receiver2)),
x=edges$freq)
movementDF <- as.data.frame(as.matrix(m))
row.names(movementDF) <- levels(as.factor(edges$receiver1))
colnames(movementDF) <- levels(as.factor(edges$receiver2))
return(movementDF)
}
data2=data[which(data$Transmitter == "A69-1601-29926"), ]
g.intervals <- intervals2graph(data2, "A69-1601-29926")
par(mar = c(0, 7, 0, 5))
plot.migration.intervals(g.intervals)
data2=data[which(data$Transmitter == "A69-1601-29919"), ]
g.intervals <- intervals2graph(data2, "A69-1601-29919")
par(mar = c(0, 7, 0, 5))
plot.migration.intervals(g.intervals)
matrix <- detections2movementmatrix(data2, "A69-1601-29926")
print(matrix)
matrix <- detections2movementmatrix(data2, "A69-1601-29919")
data2=data[which(data$Transmitter == "A69-1601-29926"), ]
g.intervals <- intervals2graph(data2, "A69-1601-29926")
par(mar = c(0, 7, 0, 5))
plot.migration.intervals(g.intervals)
library(zoo)
library(dplyr)
# Load in emigration data
dataE<-"dataE.csv"
dataE<-read.csv(dataE, header=TRUE, stringsAsFactors=FALSE)
library(igraph)
library(lubridate)
library(Matrix)
library(plyr)
library(sna)
par(mar = c(0, 7, 0, 5))
# Generate graph for dataE
g.intervals <- intervals2graph(dataE, "A69-1601-31897")
plot.migration.intervals(g.intervals)
g.intervals <- intervals2graph(dataE, "A69-1601-29950")
plot.migration.intervals(g.intervals)
g.intervals <- intervals2graph(dataE, "A69-1601-29951")
plot.migration.intervals(g.intervals)
plot.migration.intervals(g.intervals)
version
library(plyr)
dataE<-"dataE.csv"
dataE<-read.csv(dataE, header=TRUE, stringsAsFactors=FALSE)
R.version()
R.Version()
rm(list = ls()) #remove all
load("~/Doctoraat/R/Creeks/Data_analyse PJ/Creeks_data_analysis_GlobalEnvironment.RData")
View(pump)
pump2=pump[which(pump$Value=!"0"),]
pump2=pump[which(pump$Value!="0"),]
View(pump2)
mean(pump2$Value)
View(dataH)
levels(dataH$Receiver)
unique(dataH$Receiver)
min(dataH$Arrival)
x=dataH[which(dataH$Transmitter="A69-1601-29924"),]
x=dataH[which(dataH$Transmitter=A69-1601-29924),]
load("~/Doctoraat/R/Creeks/Data_analyse PJ/Creeks_data_analysis_GlobalEnvironment.RData")
View(dataE)
setwd("C:/Users/Pieterjan/Documents/Doctoraat/Github/fish-tracking/analysis/receiver_distance_analysis")
path<-"C:/Users/Pieterjan/Documents/Doctoraat/Github/fish-tracking/analysis/receiver_distance_analysis"
rm(list = ls()) #remove all
library("sp")
library("rgdal")
library("rgeos")
library("raster")
library("gdistance")
library("assertthat")
# --------------------
# INTRODUCTION
# --------------------
# Define the projection for the analysis:
coordinate.string <- CRS("+init=epsg:32631")
# Load the functionalities from the functions file:
source("receiver_distance_fun.R")
# --------------------
# LOAD SHAPEFILES
# --------------------
# RIVER SECTION
river.names <- c("Schelde", "Durme", "Rupel", "Netekanaal",
"Albertkanaal", "Royerssluis", "Leopolddok",
"Amerikadok", "Vijfde Havendok", "Kanaaldok B3", "Delwaidedok",
"Schelde-Rijnkanaal", "Berendrechtsluis", "Hansadok",
"Kanaaldok B2", "Schelde-Rijn Kanaal",
"Zandvlietsluis", "Ringvaart", "Tijarm",
"Kanaal van Gent naar Oostende","Canal Albert","Demer","Dijle")
## for future usage:
# "Meuse", "Juliana Kanaal", "Canal Albert", "Demer", "Dijle"
rivers <- load.shapefile("./data/lowcountries_water/LowCountries_Water_2004.shp",
"LowCountries_Water_2004",
coordinate.string,
river.names)
# NETE SECTION (precompiled as Europe entire file is very large)
nete <- load.shapefile("./data/europe_water/nete.shp",
"nete",
coordinate.string,
subset.names = NULL)
## to restart from the entire Europe shapefile:
## nete <- load.shapefile("./data/europe_water/Europe_Water_2008.shp",
##                        "Europe_Water_2008",
##                        coordinate.string,
##                        c("Nete", "Grote Nete"))
# WESTERSCHELDE
westerschelde <- load.shapefile("./data/westerschelde_water/seavox_sea_area_polygons_v13.shp",
"seavox_sea_area_polygons_v13",
coordinate.string)
# SEA + missing parts Albert Canal
sea <- load.shapefile("./data/PJ_manual_water/PJ_ontbrekende_stukken_reduced.shp",
"PJ_ontbrekende_stukken_reduced",
coordinate.string)
# -----------------------
# COMBINE THE SHAPE FILES
# -----------------------
study.area <- gUnion(rivers, nete)
study.area <- gUnion(study.area, westerschelde)
study.area <- gUnion(study.area, sea)
# clean workspace from individual shapefiles
rm(rivers, nete, westerschelde, sea)
# ----------------
# LOAD RECEIVERS
# ----------------
locations.receivers <- load.receivers("./data/receivernetwork_20161129.csv",
coordinate.string)
# ------------------------
# CONVERT SHAPE TO RASTER
# ------------------------
# for alternative resolutions, change the number of rows/columns
nrows <- 2000
ncols <- 4000
study.area.binary <- shape.to.binarymask(study.area, nrows, ncols)
# --------------------------------
# ADJUST MASK TO CONTAIN RECEIVERS
# --------------------------------
study.area.binary.extended <- adapt.binarymask(study.area.binary, locations.receivers)
# write this to disk for loading in e.g. QGIS
writeRaster(study.area.binary.extended, "./results/study_area_binary", "GTiff",
overwrite = TRUE)
# --------------------------------
# CONTROL MASK
# --------------------------------
# Control the mask characterstics and receiver location inside mask:
# (if an error occurres, this need to be checked before deriving distances again)
control.mask(study.area.binary.extended, locations.receivers)
# -------------------------------
# Derive distances with gdistance
# -------------------------------
cst.dst.frame <- get.distance.matrix(study.area.binary.extended, locations.receivers)
# write.csv(cst.dst.frame, "./results/cst_dist_receivers_ak.csv")
# IDEA ...
# Could be interesting to compare these values with the commute distances:
# see: https://cran.r-project.org/web/packages/gdistance/vignettes/gdistance1.pdf
# commute.dst <- commuteDistance(tr_geocorrected, matched.receivers)
# By running many paths and extracting average statistics about the distance a
# more in-depth insight in travel distance could be achieved
write.csv(cst.dst.frame, "./results/cst_dist_receivers_2.csv")
